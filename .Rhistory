summary(fit)
# Plota as previsões com intervalos de confiança de 80% e 95%:
plot(fit,main="Previsões x Valores Observados nos Últimos 7 meses")
lines(validacao,lty=3)
# Carregando a Biblioteca Forecast:
library(forecast)
# Carregando os dados:
dados <- read.table("clipboard")
serie <- ts(dados,start=c(1999,12),end=c(2020,7),frequency=12)
# Definindo os periodos de treino e validação:
treino <- window(serie,end=c(2019,12))
validacao <- window(serie,start=c(2020,1))
# Aplicando o Metodo de Holt para obter previsões para até 7 passos à frente:
fit <- hw(treino,h=7)
# Exibir as Constantes de Amortecimento Estimadas e as Previsões:
summary(fit)
# Plota as previsões com intervalos de confiança de 80% e 95%:
plot(fit,main="Previsões x Valores Observados nos Últimos 7 meses")
lines(validacao,lty=3)
# Carregando a Biblioteca Forecast:
library(forecast)
# Carregando os dados:
dados <- read.table("clipboard")
serie <- ts(dados,start=c(2000,1),end=c(2019,12),frequency=12)
# Definindo os periodos de treino e validação:
treino <- window(serie,end=c(2018,12))
validacao <- window(serie,start=c(2019,1))
# Aplicando o Metodo de Holt para obter previsões para até 7 passos à frente:
fit <- hw(treino,h=12)
# Exibir as Constantes de Amortecimento Estimadas e as Previsões:
summary(fit)
# Plota as previsões com intervalos de confiança de 80% e 95%:
plot(fit,main="Previsões x Valores Observados nos Últimos 7 meses")
lines(validacao,lty=3)
# Carregando a Biblioteca Forecast:
library(forecast)
# Carregando os dados:
dados <- read.table("clipboard")
serie <- ts(dados,start=c(2000,1),end=c(2019,12),frequency=12)
# Definindo os periodos de treino e validação:
treino <- window(serie,end=c(2018,12))
validacao <- window(serie,start=c(2019,1))
# Aplicando o Metodo de Holt para obter previsões para até 7 passos à frente:
fit <- hw(treino,h=12,seasonal = "multiplicative")
# Exibir as Constantes de Amortecimento Estimadas e as Previsões:
summary(fit)
# Plota as previsões com intervalos de confiança de 80% e 95%:
plot(fit,main="Previsões x Valores Observados nos Últimos 7 meses")
lines(validacao,lty=3)
library(forecast)
dados <- read.table("clipboard")
serie <- ts(dados, start=c(2005,1), end=c(2019,12), frequency=12)
treino <- window(serie, end=c(2018,12))
validacao <- window(serie,start=c(2019,1))
# definimos os períodos de treino e validação
fit <- ses(treino, h=1)
# aplica o método para obter previsões para até 12 passos à frente (horizonte)
summary(fit)
plot(fit,main = "Previsões x Valores Observados nos Últimos 12 meses")
# plota as previsões com intervalos de confiança de 80% a 95%
lines(validacao,lty=3)
library(forecast)
dados <- read.table("clipboard")
serie <- ts(dados, start=c(2005,1), end=c(2019,12), frequency=12)
treino <- window(serie, end=c(2018,12))
validacao <- window(serie,start=c(2019,1))
# definimos os períodos de treino e validação
fit <- ses(treino, h=12)
# aplica o método para obter previsões para até 12 passos à frente (horizonte)
summary(fit)
plot(fit,main = "Previsões x Valores Observados nos Últimos 12 meses")
# plota as previsões com intervalos de confiança de 80% a 95%
lines(validacao,lty=3)
library(sampling)
data(MU284)
table(MU284$REG) # obtem uma tabela com os possiveis estratos
prop.table(table(MU284$REG)) # obtem o peso de cada estrato
np = 80 # tamanho da amostra planejado
np * prop.table(table(MU284$REG)) # alocação proporcional da amostra
# Selecionando a Amostra Estratificada:
set.seed(3)
selec = strata(MU284,stratanames = "REG",size=c(8,14,10,11,16,12,5,9),method = "srswor")
# Obtendo a Amostra da base de dados MU284:
amostra = getdata(MU284,selec)
# Criando o vetor fpc com os totais populacionais dos estratos:
fpc = rep(c(25,48,32,38,56,41,15,29),c(8,14,10,11,16,12,5,9))
# Especificação do Plano Amostral:
library(survey)
plano_est = svydesign(id=~1,strata=~Stratum,probs=~selec$Prob,data=amostra,fpc=~fpc)
# Estimação da Media Populacional e de seu Erro Padrão no Plano Estratificado:
svymean(~RMT85,plano_est)
library(sampling)
data(MU284)
table(MU284$REG) # obtem uma tabela com os possiveis estratos
prop.table(table(MU284$REG)) # obtem o peso de cada estrato
np = 50 # tamanho da amostra planejado
np * prop.table(table(MU284$REG)) # alocação proporcional da amostra
# Selecionando a Amostra Estratificada:
set.seed(3)
selec = strata(MU284,stratanames = "REG",size=c(8,14,10,11,16,12,5,9),method = "srswor")
library(sampling)
data(belgianmunicipalities)
dados = belgianmunicipalities
table(belgianmunicipalities$Province)
set.seed(10)
ACS=cluster(belgianmunicipalities,clustername = c("Province"),size = 3,method = c('srswor'))
ACSs = getdata(belgianmunicipalities,ACS)
fpc2 = rep(9,dim(ACSs)[1])
library(survey)
PlanoC = svydesign(id=~Province,data=ACSs,probs=~ACS$Prob,fpc=~fpc2)
svymean(~averageincome,PlanoC)
getOption("vsc.use_httpgd")
q()
ls
print("Coding in R")
?print()
z <- c(4:10)
z
setwd("C:/Users/bruno/OneDrive - MSFT/01 Cursos/Certificação - Google - Data Analytics/Curso 7")
# Vetores e Listas
# Vetores Atomicos:
a <- c(2.5,48.5,101.5) # criação normal
b <- c(3:10) # criando por uma sequencia de valores
typeof(a) # tipo de dados no vetor
is.integer(a) # verificando por um tipo de dado especifico
is.integer(c)
length(a) # comprimento/numero de elementos do vetor
names(a) <- c("a","b","c") # nomeando os elementos do vetor
a[2] # retornando o segundo elemento por seu indice
a["b"] # retornando o segundo elemento por seu nome
# Listas
c <- list("a",1l,1.5,TRUE) # criando uma lista com elementos diversos
# Vetores e Listas
# Vetores Atomicos:
a <- c(2.5,48.5,101.5) # criação normal
b <- c(3:10) # criando por uma sequencia de valores
typeof(a) # tipo de dados no vetor
is.integer(a) # verificando por um tipo de dado especifico
is.integer(c)
length(a) # comprimento/numero de elementos do vetor
names(a) <- c("a","b","c") # nomeando os elementos do vetor
a[2] # retornando o segundo elemento por seu indice
a["b"] # retornando o segundo elemento por seu nome
# Listas
c <- list("a",1,1.5,TRUE) # criando uma lista com elementos diversos
str(c) # verificando a estrutura de dados na lista
d <- list(list(1,3,5)) # criando uma lista dentro de uma lista
Str(d) # estrutura de uma lista dentro de uma lista
# Vetores e Listas
# Vetores Atomicos:
a <- c(2.5,48.5,101.5) # criação normal
b <- c(3:10) # criando por uma sequencia de valores
typeof(a) # tipo de dados no vetor
is.integer(a) # verificando por um tipo de dado especifico
is.integer(c)
length(a) # comprimento/numero de elementos do vetor
names(a) <- c("a","b","c") # nomeando os elementos do vetor
a[2] # retornando o segundo elemento por seu indice
a["b"] # retornando o segundo elemento por seu nome
# Listas
c <- list("a",1,1.5,TRUE) # criando uma lista com elementos diversos
str(c) # verificando a estrutura de dados na lista
d <- list(list(1,3,5)) # criando uma lista dentro de uma lista
str(d) # estrutura de uma lista dentro de uma lista
e <- list('chicago' = 1, 'nova york' = 2, 'los angeles' = 3) lista com valores nomeados
# Vetores e Listas
# Vetores Atomicos:
a <- c(2.5,48.5,101.5) # criação normal
b <- c(3:10) # criando por uma sequencia de valores
typeof(a) # tipo de dados no vetor
is.integer(a) # verificando por um tipo de dado especifico
is.integer(c)
length(a) # comprimento/numero de elementos do vetor
names(a) <- c("a","b","c") # nomeando os elementos do vetor
a[2] # retornando o segundo elemento por seu indice
a["b"] # retornando o segundo elemento por seu nome
# Listas
c <- list("a",1,1.5,TRUE) # criando uma lista com elementos diversos
str(c) # verificando a estrutura de dados na lista
d <- list(list(1,3,5)) # criando uma lista dentro de uma lista
str(d) # estrutura de uma lista dentro de uma lista
e <- list('chicago' = 1, 'nova york' = 2, 'los angeles' = 3) #lista com valores nomeados
is.integer(b)
install.packages("tidyverse")
library(tidyverse)
library(lubridate)
today() # exibe a data atual
now() # exibe a data e hora atuais
today() # exibe a data atual
now() # exibe a data e hora atuais
ymd("2023-01-20") # converte a string com ano-mes-dia em data
mdy("January 20th, 2023") # converte a string com mes-dia-ano em data
dmy("20-jan-2021") # converte a string com dia-mes-ano em data
ymd(20210120) # converte uma cadeia de numeros em data
ymd_hms("2021-01-20 20:11:59") # converte a string em data hora
mdy_hm("01/20/2021 08:01") # converte a string em data hora
as_date(now()) # extrai uma data de um data hora
install.packages(c("bit", "bslib", "cli", "clock", "commonmark", "cpp11", "curl", "data.table", "gert", "hardhat", "httpgd", "httr2", "jsonlite", "knitr", "lintr", "markdown", "mime", "odbc", "openssl", "parallelly", "pillar", "pkgbuild", "processx", "ps", "purrr", "quantmod", "R.utils", "R6", "RcppArmadillo", "recipes", "renv", "sessioninfo", "stringi", "systemfonts", "tinytex", "tzdb", "unigd", "xfun", "xml2", "zip", "zoo"))
data("airquality")
View(airquality)
# Exemplo com AND:
airquality[,"Solar.R"] > 150 & airquality[,"Wind"] > 10
# Exemplo com AND:
boas_condicoes <- airquality[,"Solar.R"] > 150 & airquality[,"Wind"] > 10
airquality[,"Solar.R"] > 150 | airquality[,"Wind"] > 10
airquality[,"Day"] != 1
x <- 4
if (x>1) {
print("X is a positive number")
}
x <- 4
if (x>0) {
print("X is a positive number")
}
y <- 7
if(y>0) {
print("y is a positive number.")
} else {
print("y is either a negative number or zero")
}
z <- -1
if(z<0) {
print("z is a negative number.")
} else if (z == 0) {
print("z is zero.")
} else {
print("z is a positive number")
}
x <- 50
x > 35 & x< 65
x <- 60
x > 35 & x< 65
installed.packages()
install.packages("base")
install.packages(tidyverse)
tidyverse_update()
clear
ls
library(tidyverse)
tidyverse_update()
install.packages(c("ggplot2", "jsonlite", "ragg", "rlang", "xml2"))
update.packages()
library(tidyverse)
browseVignettes("tibble")
data("ToothGrowth")
View(ToothGrowth)
library(dplyr)
filtered_tg <- (ToothGrowth, dose == 0.5)
filtered_tg <- (ToothGrowth, dose == 0.5)
filtered_tg <- (ToothGrowth,dose == 0.5)
filtered_tg <- (ToothGrowth,dose == 0.5)
filtered_tg <- (ToothGrowth dose == 0.5)
library(dplyr)
filtered_tg <- (ToothGrowth, dose = 0.5)
filtered_tg <- (ToothGrowth, dose == 0.5)
filtered_tg <- filter(ToothGrowth, dose == 0.5)
arrange(filtered_tg, len)
arrange(filter(ToothGrowth, dose == 0.5), len)
filtered_toothgrowth <- ToothGrowth %>%
filter(dose == 0.5) %>%
arrange(len)
filtered_toothgrowth
filtered_toothgrowth <- ToothGrowth %>%
filter(dose == 0.5) %>%
group_by(supp) %>% #agrupa os dados
summarize(mean_len = mean(len,na.rm=T), .group ="drop")
filtered_toothgrowth
library(ggplot2)
data("diamonds")
View(diamonds)
head(diamonds) # vizualiza os primeiros registros do Data Frame
str(diamonds) # vizualiza a estrutura do Data Frame
colnames(diamonds) # visualiza apenas os nomes das colunas do Data Frame
library(dplyr)
mutate(diamonds,carat_2 = carat * 100)
head(diamonds)
library(dplyr)
mutate(diamonds,carat_2 = carat * 100)
View(diamonds)
library(tidyverse)
mutate(diamonds,carat_2 = carat * 100)
names <- c("Pedro","Paulo","Jose","Maria")
ages <- c(71,48,58,63)
people <- data.frame(names,ages)
people
# Visualizando as primeiras linhas de dados:
head(people)
# Obtendo resumos sobre os dados:
str(people)
glimpse(people)
glimpse(people)
library(tidyverse)
glimpse(people)
# Obtendo uma lista com os nomes das colunas no Data Frame:
colnames(people)
# Adicionando uma nova coluna ao Data Frame:
mutate(people,age_in_20 = ages + 20)
str(people)
# Criando um vetor de frutas:
frutas <- c("uva","pera","banana","maça","laranja")
# Criando um vetor com o rank das frutas:
ranks <- c(4,5,2,3,1)
# Combinando os vetores em um novo Data Frame:
fruit_ranks <- data.frame(frutas,ranks)
# Verificando Data Frame criado:
str(fruit_ranks)
# Ordenando as linhas pelos ranks:
fruit_rankeado <- fruit_ranks[order(fruit_ranks$ranks)]
# Combinando os vetores em um novo Data Frame:
fruit_ranks <- data.frame(frutas,ranks)
# Criando um vetor de frutas:
frutas <- c("uva","pera","banana","maça","laranja")
# Criando um vetor com o rank das frutas:
ranks <- c(4,5,2,3,1)
# Combinando os vetores em um novo Data Frame:
fruit_ranks <- data.frame(frutas,ranks)
# Verificando Data Frame criado:
str(fruit_ranks)
# Ordenando as linhas pelos ranks:
fruit_rankeado <- fruit_ranks[order(fruit_ranks$ranks)]
# Ordenando as linhas pelos ranks:
fruit_rankeado <- fruit_ranks[order(fruit_ranks$ranks),]
fuit_rankeado
fruit_rankeado
library(tidyverse)
data("diamonds")
diamonds_tibble <- as_tibble(diamonds)
diamonds_tibble
data() # carrega todos os conjuntos de dados disponiveis no R
data("mtcars")
View(mtcars)
mtcars
str(mtcars)
library(tidyverse)
readr_example()
# Carregando dados de um arquivo .csv com a função read_csv() do pacote readr:
read_csv(readr_example("mtcars.csv"))
# Carregando dados de um arquivo do excel (.xlsx):
library(readxl)
read_excel(readxl_example("type_me.xlsx"))
readxl_example()
read_excel(readxl_example("type-me.xlsx"))
# Carregando uma planilha/aba específica de um arquivo do excel:
read_excel(readxl_example("type-me.xlsx"), sheet="numeric_coercion")
library(tidyverse)
# Lendo o arquivo CSV:
bookings_df <- read_csv("hotel_bookings.csv")
head(bookings_df) # lendo os primeiros registros
str(bookins_df) # resume as colunas dos data frame horizontalmente
str(bookings_df) # resume as colunas dos data frame horizontalmente
colnames(bookings_df) # retorna os nomes das colunas do Data Frame
new_df <- select(bookings_df,'adr','adults')
# salva em um novo data frame
new_df
mutate(new_df, total = 'adr'/'adults')
mutate(new_df, total = 'adr'/adults)
mutate(new_df, total = `adr` / adults)
install.packages("here")
install.packages("skimr")
install.packages("janitor")
library("here")
library("skimr")
library("janitor")
library("tidyverse")
library("dplyr")
install.packages("palmerpenguins")
library("palmerpenguins")
# Resumindo os dados:
skim_without_charts(penguins)
glimpse(penguins)
head(penguins)
# Selecionando e obtendo colunas específicas do conjunto de dados:
penguins %>%
select(species)
# Excluindo uma coluna da seleção:
penguins %>%
select(-species)
# Renomeando colunas com a função rename():
penguins %>%
rename(island_new=island)
# Alterando todos os nomes das colunas do dataset:
rename_with(penguins,toupper)
# Verificando a consistência dos nomes das colunas:
clean_names(penguins)
library(tidyverse)
library(palmerpenguins)
penguins %>%
arrange(bill_length_mm)
penguins %>%
arrange(-bill_length_mm)
penguins2 <- penguins %>%
arrange(bill_length_mm)
penguins2
penguins2 <- penguins %>%
arrange(-bill_length_mm)
penguins2
penguins %>%
group_by(island) %>% #agrupa pela coluna island
drop_na() %>% # exclui os registros vazios
summarize(mean_bill_length_mm = mean(bill_length_mm)) # obtem a media da coluna
penguins %>%
group_by(island) %>% #agrupa pela coluna island
drop_na() %>% # exclui os registros vazios
summarize(max_bill_length_mm = max(bill_length_mm)) # obtem a maximo da coluna
penguins %>%
group_by(species,island) %>% #agrupa pela coluna species e island
drop_na() %>% # exclui os registros vazios
summarize(min_bill_length_mm = min(bill_length_mm), max_bill_length_mm = max(bill_length_mm))
# obtem os minimos e maximos dos agrupamentos
penguins %>%
filter(species == "Adelie")
# Carregando as bibliotecas necessárias:
library(tidyverse)
library(skimr)
library(janitor)
bookings_df <- read_csv("hotel_bookings.csv")
head(bookings_df) # visualiza os primeiros dados do dataset
str(bookings_df) # resume os dados
glimpse(bookings_df) # resume os dados com mais detalhes
colnames(bookings_df) # obtem os nomes das colunas do dataset
skim_without_charts(bookings_df) # obtem um resumo detalhado dos dados
trimmed_df <- bookings_df %>%
select(hotel,is_canceled,lead_time)
trimmed_df
trimmed_df %>%
select(hotel,is_canceled,lead_time) %>%
rename(hotel_type = hotel)
trimmed_df
example_df <- bookings_df %>%
select(arrival_date_year,arrival_date_month) %>%
unite(arrival_month_year, c("arrival_date_month","arrival_date_year"),sep="")
example_df
example_df <- bookings_df %>%
select(arrival_date_year,arrival_date_month) %>%
unite(arrival_month_year, c("arrival_date_month","arrival_date_year"),sep="-")
example_df
example_df <- bookings_df %>%
mutate(guests = adults,children, babies)
example_df
example_df <- bookings_df %>%
mutate(guests = adults + children + babies)
example_df
example_df[guests,]
example_df[guests]
example_df <- bookings_df %>%
summarize(number_canceled = sum(is_canceled))
example_df
id <- c(1:10)
name <- c("John Mendes", "Rob Stewart", "Rachel Abrahamson", "Christy Hickman", "Johnson Harper", "Candace Miller", "Carlson Landy", "Pansy Jordan", "Darius Berry", "Claudia Garcia")
job_title <- c("Professional", "Programmer", "Management", "Clerical", "Developer", "Programmer", "Management", "Clerical", "Developer", "Programmer")
employee <- data.frame(id, name, job_title)
head(employee)
# Dividindo a coluna name em duas: first_name e last_name:
separate(employee,name,into=c('first_name','last_name'),sep=" ")
first_name <- c("John", "Rob", "Rachel", "Christy", "Johnson", "C++", "Carlson", "Pansy", "Darius", "Claudia")
last_name <- c("Mendes", "Stewart", "Abrahamson", "Hickman", "Harper", "Miller", "Landy", "Jordan", "Berry", "Garcia")
# Novo Data Frame:
first_name <- c("John", "Rob", "Rachel", "Christy", "Johnson", "C++", "Carlson", "Pansy", "Darius", "Claudia")
last_name <- c("Mendes", "Stewart", "Abrahamson", "Hickman", "Harper", "Miller", "Landy", "Jordan", "Berry", "Garcia")
job_title <- c("Professional", "Programmer", "Management", "Clerical", "Developer", "Programmer", "Management", "Clerical", "Developer", "Programmer")
employee <- data.frame(id, first_name, last_name, job_title)
print(employee)
# Combinando duas colunas em uma: first_name e last_name em name:
unite(employee,'name',first_name,last_name,sep=' ')
library(palmerpenguins)
penguins %>%
mutate(body_mass_kg - body_mass_g / 1000)
library(palmerpenguins)
penguins %>%
mutate(body_mass_kg = body_mass_g / 1000)
library(palmerpenguins)
penguins %>%
mutate(body_mass_kg = body_mass_g / 1000)
library(palmerpenguins)
penguins %>%
mutate(body_mass_kg = body_mass_g / 1000)
library(palmerpenguins)
penguins %>%
mutate(body_mass_kg = body_mass_g / 1000, flipper_length_m = flipper_length_mm/1000)
library(palmerpenguins)
penguins %>%
mutate(body_mass_kg = body_mass_g / 1000, flipper_length_m = flipper_length_mm/1000)
install.packages('Tmisc')
# Obtendo o dataset Anscombe's quartet:
library(Tmisc)
data(quartet)
View(quartet)
quartet %>%
group_by(set)%>%
summarize(mean(x),sd(x),mean(y),sd(y),cor(x,y))
# Como as medidas estatísticas são praticamente as mesmas
# Precisamos plotar visualizações para verificar diferenças entre os dados:
ggplot(quartet,aes(x,y)) + geom_pint() + geom_smooth(method = lm,se = FALSE) + facet_wrap(~set)
# Como as medidas estatísticas são praticamente as mesmas
# Precisamos plotar visualizações para verificar diferenças entre os dados:
ggplot(quartet,aes(x,y)) + geom_point() + geom_smooth(method = lm,se = FALSE) + facet_wrap(~set)
install.packages('datasauRus')
library(datasauRus)
ggplot(datasaurus_dozen,aes(x=x,y=y,colour=dataset))+geom_point()+theme_void()+theme(legend.position = "none")+facet_wrap(~dataset,ncol=3)
install.packages('SimDesign')
library(SimDesign)
actual_temp <- c(68.3,70,72.4,71,67,70)
predicted_temp <- c(67.9,69,71.5,70,67.69)
# Função que verifica vieses entre os dados - quanto menor o resultado, mais imparcial
bias(actual_temp,predicted_temp)
actual_temp <- c(68.3,70,72.4,71,67,70)
predicted_temp <- c(67.9,69,71.5,70,67,69)
# Função que verifica vieses entre os dados - quanto menor o resultado, mais imparcial
bias(actual_temp,predicted_temp)
actual_sales <- c(150,203,137,247,116,287)
predicted_sales <- c(200,300,150,250,150,300)
bias(actual_sales,predicted_sales)
